<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.26" />

  <title>如何把Angular1.x项目迁移到es6？ &middot; ParaofHeaven</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://paraofheaven.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://paraofheaven.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://paraofheaven.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://paraofheaven.github.io/img/favicon.ico" type="image/x-icon" />

  
    <link rel="stylesheet" href="https://paraofheaven.github.io/css/my.css">
  
  
    <script src="https://paraofheaven.github.io/js/my.js"></script>
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://paraofheaven.github.io/">ParaofHeaven</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://paraofheaven.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://paraofheaven.github.io/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://paraofheaven.github.io/shot/"><i class='fa fa-photo fa-fw'></i>Shots</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://paraofheaven.github.io/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://paraofheaven.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/paraofheaven" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://bitbucket.org/*" target="_blank"><i class="fa fa-bitbucket-square fa-fw"></i>Bitbucket</a>
    </li>
    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://stackoverflow.com/users/paraofheaven" target="_blank"><i class="fa fa-stack-overflow fa-fw"></i>Stack Overflow</a>
    </li>
    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://steamcommunity.com/id/paradiseyong" target="_blank"><i class="fa fa-steam-square fa-fw"></i>Steam</a>
    </li>
    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2017. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>如何把Angular1.x项目迁移到es6？</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>08 Nov 2017, 14:15</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://paraofheaven.github.io/tags/angular">Angular</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://paraofheaven.github.io/tags/es6">es6</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://paraofheaven.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84">项目重构</a>
    
  </div>
  
  

</div>

  <p>In parahome on 2017-11-08 by para</p>

<h4 id="前言">前言</h4>

<p><strong>或许有着这些那些的掣肘，但改变还是必须的，否则我们无法知道团队到底需要什么样的框架。</strong></p>

<p>大概今年九月中旬的时候，我们团队开始决心对系统框架基于Angular1.x进行迁移，一方面，前端针对es6的改造已是势在必行的事，项目迁移到React也早已被提上日程，但是直接从Angular1.x过渡到React显得不太实际，毕竟React的体系不是人人都熟悉，重构项目的同时需求也跟着同时开发，es6的语法也需要慢慢过渡着来。幸运的是，我对es6的体系比较熟悉，第一个开始试点的项目也从程程白条开始进行。在此之前，春哥已经将基础框架和组件库更新到es6版本（基础开发库请参考<a href="https://www.npmjs.com/package/venus-cli">venus-cli</a>），我所做的主要是业务代码方面的迁移.这中间包含了我自己对设计理念的一些实现，这里尝试做一些阐述，请有针对性的吸收。</p>

<p></p>

<p>在项目重构前我们需要考虑清楚，这次重构我们需要将框架和业务分离到哪种层次，讨论的结果是，
1. 变动越小越好，旧项目最好能够不修改并且能保证运行，保证向下兼容
2. 接口和业务逻辑的变动应当慎之又慎，
3. es6的语法糖有选择性的引入，不考虑es7的decorator等模式。</p>

<p>决定这些因素后我们需要考虑以下几个问题：
1. <strong>徐飞</strong>和<strong>kuitos</strong>在各自的文中都不约而同得将消除Angualr显式的$scope作为第一要务，但这种决定是否符合我们团队的选择，有待商榷。
2. es6的class目前来看比较符合我们变动不大的需求，因为给controller，service，directive和factory的外层简单包裹一层class的语法糖，不仅使定义的过程更加自然，而且符合我们按需引入的需求。
3. 是否使用controllerAs的语法糖，上面提到的两位大大也无一例外的提到了controllerAs+class的改造方式，实现出来的模块加组件的方式清晰又明确，而且保证了viewModel（视图模型的）的纯洁性（虽然页面上我写起来也感觉再多写一个前置变量有些繁琐），但是最终还是没有采用，原因我接下来会说。
4. 解决繁琐的Angular的依赖注入问题。Angular之前的依赖注入写法真的很容易让人崩溃，完全没有组件化引入的形式不说，格式还特别严格，稍有错误就会给你报未知错误，而且错误也很难定位，示例如下，这种挂香肠的代码也是写够了😫。。。</p>

<pre><code>app.controller('Order.indexCtrl', [
  '$timeout',
  '$scope',
  '$q',
  '$state',
  'RepayOrderService',
  'hybridBridge',
  'signals',
  'envConfig',
  function (
    $timeout,
    $scope,
    $q,
    $state,
    RepayOrderService,
    hybrid,
    signals,
    envConfig
  ) {

  }])
</code></pre>

<h4 id="模块机制的改造">模块机制的改造</h4>

<p>之前我们并没有使用Angular的模块机制，而是使用了一套叫做enyo.depends的东西，现在既然es6提供了cmd模块加载机制，那么这套老旧的东西就可以扔掉了。但是，Angular1.x还是套了一层套子在我们身上，他的意思是，你的模块想在我的框架中运行，就必须按照我的意图去定义module，即angular.module。
举例说明：
现在我们全局定义一个app,所有的angular服务都定义在app上，定义了服务名，并注入了一些服务。</p>

<pre><code>// MainCtrl 基础组件库
import MainCtrl from 'core';
// sentry 是第三方线上错误日志收集框架
import sentry from 'sentry';
window.app = angular.module('angular_jfwebapp', ['venus', 'sentry'])
  .controller('mainCtrl', MainCtrl)
  .run(() =&gt; sentry.init());
</code></pre>

<p>现在这个全局的app就能被我在任意模块或者组件中引用和注册服务了。
这样的话，旧项目的controller甚至不用修改就能直接使用，因为它也是注册在app上的服务，只用稍加修改模块的引用机制即可。</p>

<h4 id="改造的选择">改造的选择</h4>

<p>之前提到过，关于controller的改造我们有两种可行的方案，一种是只将controller套上class的语法糖，所有的依赖注入机制还是走$scope的那一套，即原来的$scope变成this.$scope，还有一种就是Angular1.2版本后所提倡的controllerAs的写法，这种写法提供了一套将controller中class中的变量隐射到$scope上的语法糖，意思是在class中定义在this上的变量可以被映射到页面上，而不再需要$scope这个中间件，代码很清爽也很好看:
比如:</p>

<p>controller/index.js</p>

<pre><code>class IndexCtrl {
  static $inject = ['$scope'];
  constructor($scope) {
    this.$scope = $scope;
    this.init();
  }
  init() {
    this.name = 'angular&amp;es6';
  }
  getName(){
    console.log('app's name is ' + this.name);
  }
}

app.controller('IndexCtrl', IndexCtrl);
</code></pre>

<p>index.html</p>

<pre><code>&lt;div class=&quot;page&quot; ng-controller=&quot;indexCtrl as app&quot;&gt;
  &lt;div ng-bind=&quot;app.name&quot;&gt;&lt;/div&gt;
  &lt;button ng-click=&quot;app.getName()&quot;&gt;get app name&lt;/button&gt;
&lt;/div&gt;
</code></pre>

<p>看起来很美好是不是？但是，现实往往是残酷的&hellip;</p>

<p>首先，改动会很大，基本上所有的controller, service, directive, factory都需要改造，这肯定是不可避免的，但这对于我这种爱折腾的肯定不成问题。接下来的问题就是不得不面对的了。
1. 我们目前的框架脱离不了$scope,大量和业务挂钩的方法都挂载在scope上，比如hybrid, eventTrack,和最重要的组件都挂载在scope上，目前框架内所有的dialog都是基于ngDialog开发，如果脱离了ngDialog,我们没有精力去重新造一个弹窗的轮子来。但是，这个问题可以克服，解决办法就是我们在依赖中将$scope注入，并绑定为this的属性，虽然写法上成了难看的<code>this.$scope.ngDialog</code>，但是毕竟能用了不是。
2. 关于指令link中属性计算的问题
  directive: 指令的使用通常会出现依赖属性计算或者监听的场景，</p>

<pre><code>  $scope.$watch('running',function(newValue){
    if(newValue){
      $scope.state = false;
    }
  });
</code></pre>

<p>改造成es6形式如下：</p>

<pre><code>  this.$scope.$watch('running',(newValue)=&gt;{
    if(newValue){
      this.state = false;
    }
  })
</code></pre>

<p>这种的虽然可以用了，但是还是存在一种基于accessor的写法：</p>

<pre><code>  class Driective {
    get running(){
      this.state = this.running ? true : false;
    }
  }
</code></pre>

<p>这样当running发生变化时，state的值也会发生相应的改变。但是徐飞指出了一种不知名的原因导致绑定失效，导致不得不使用$watch的情况，kuitos解决的办法是采用angualr.component中新的语法,生命周期中的$onChanges去监听属性值得变化，但是这又会导致带来副作用，$onChanges回调有个限制是，它的变量检测是引用检查而不是值检查，也就是说，监听引用类型的变量根本不起作用，目前能够解决这种问题的方法可能就是需要引入不可变变量的概念，即immutablejs。事情不但没有解决，反而引来了更多的问题，何况，我们还没有引入component的计划。</p>

<ol>
<li>$on, $watch, $emit带来的问题
之前在ng中模块或者组件之间的通信直接依赖$watch,$on和$broadcast，现在没有了这些，我们还怎么做通信？从React和vue走过来的我们明白，不能过度依赖跨组件间的通信机制，通常，非必要的场景，我们可以使用inline-component解决这个问题。
<code>
const user ={
template: '&lt;button type=&quot;button&quot; ng-click=&quot;$ctrl.change('kuitos')&quot;&gt;click me&lt;/button&gt;',
controller: class {
    click(userName) {
        this.onClick({userName});
    }   
},
bindings: {
    onClick: '&amp;'
}
}
app.commponent('user', user);
</code>
Usage:
<code>
&lt;user on-click=&quot;logUserName(username)&quot;&gt;&lt;/user&gt;
</code></li>
</ol>

<p>如果我们需要在不存在父子关系的节点上做通信时，我们可以使用自定义的事件中介者来完成,如kiutos大大提供的<a href="https://github.com/kuitos/angular-es-utils">eventBus</a>，我们内部使用的是自定义的signal广播机制。</p>

<p>以上种种原因都可以克服，但是我们意识到，所有这一切的改动都是牵一发而动全身的，想要优雅的抽出$scope，基本是只留一个月的重构时间的我们无法完成的。
  春哥也适时的打击了我一句，他的mergePropsToScope（后面会提到）可以有目的性的将需要的方法输出到view上，而controllerAs将class绑定到this上的变量，view层都可以访问到，这本身就不合理，我也是哑口无言。
  这也导致了我们此次的重构全面放弃了controllerAs和component。</p>

<h4 id="我们做了哪些改变">我们做了哪些改变</h4>

<p>首先我要介绍的是一个项目中所有controller都会继承的类BaseCtrl。</p>

<pre><code>import merge from 'utils';
export default class BaseCtrl {
  merge = merge;
  static $inject = ['$scope'];
  constructor(...injectArgs) {
    const injects = this.constructor.$inject;
    injectArgs.forEach((inject, index) =&gt; {
      this[injects[index]] = inject;
    });
  }

  mergePropsToScope = (...args) =&gt; {
    args.forEach((prop) =&gt; {
      const propVal = this[prop];
      if (isUndefined(propVal)) {
        console.warn(`this.mergePropsToScope() prop['${prop}'] is undefined!`);;
      }
      this.merge(true, this.$scope, {
        [`${prop}`]: propVal
      });
    });
  }
}

</code></pre>

<p>使用方法如下：
Usage</p>

<pre><code>import BaseCtrl from 'core';
import { arrayUnion } from 'utils';

class IndexCtrl extends BaseCtrl {
  static $inject = arrayUnion(BaseCtrl.$inject ,['$scope', '$stateParams', 'indexService']);
  constructor(...props){
    super(...props);
    this.mergePropsToScope('navClick');
    this.$scope.pageInfo = 'xxx';
  }
}

</code></pre>

<p>这个方法主要是为了解决几个比较关键的问题：
1. 模块内使用Angular内置服务。
2. 存在继承类的依赖注入问题
3. 将内置服务注册到this上。</p>

<p>上文提到过，我们不准备使用es7的decorator模式，那么，kiutos团队提供的<a href="https://github.com/ShuyunFF2E/ccms-components/blob/dev/src/components/tips/TipsCtrl.js">这种</a> <code>@Inject('$scope')</code>模式我们没有采用，这种比较新颖也比较好用，推荐一下。
我们使用的办法是子类merge父类的$inject数组，这样避免了一个问题：**子类继承父类时，不需要将父类的依赖（子类不需要的）再写一遍。
针对第三个问题，我们写了一个mergePropsToScope,顾名思义,就是将props merge到ng的scope上，这样我们的contrller中可以随意使用this，只要最终调用这个方法，就可以将this上的值同步到view上，算是ng scope兼容es6的一种hack。这里有两点需要注意下：
1. 属性不需要使用该方法merge，只需要赋值到this.$scope上即可。
2. 所有在初始化时不能merge到scope中的方法需要自己再手动merge，</p>

<pre><code>  const promiseMethod = (data = {}) =&gt;{
    const deferred = this.$q.defer();
    deferred.resove(data);
    return deferred.promise;
  }
  promiseMethod(data).then((data) =&gt; {
    this.$scope.syncPageinfoModule = () =&gt; {
      tis.$scope.pageinfo = 'xxx';
    }
    // 注意这里需要同步syncPageinfoModule到scope上
    this.mergePropsToScope('syncPageinfoModule');
  })
</code></pre>

<p>这意味着，如果存在异步操作中定义了多个绑定到scope上的方法，需要手动将它们一个个绑定到scope上，所幸我们这种场景不是很多，否则也会是个大麻烦。</p>

<p>其次，所有的业务contrller继承自这个BaseCtrl,这个BaseCtrl做了什么工作呢？其实它不仅帮我们简化了$inject的方式，还帮我们merge了所有的注入依赖到this上，省却了我们在constructor中写繁琐的this.xxx = xxx的工作。</p>

<h4 id="directive的改造">directive的改造</h4>

<p>这个算是改造比较彻底的地方，我们的组件大多依赖directive写成（没有使用angular component方案），而一个directive可能包含link,compile等成员函数，可配置的tepl和controller，这里面我们主要思考了如下几个问题：
1. 如何改造成class模式的代码
2. 成员函数如何处理
3. $scope如何尽可能消除</p>

<p>angular1.x在<a href="https://docs.angularjs.org/api/">最新版本</a>已经尽可能的弱化了component和directive的区别。</p>

<pre><code>// DatePickerCtrl.js
export default class DatePickerCtrl {

  $onInit() {
      this.date = `${this.year}-${this.month}`;
  }
  getMonth() {
      ...
  }
  getYear() {
      ...
  }
}
</code></pre>

<p>在模块的入口文件index.js</p>

<pre><code>// index.js
import template from './date-picker.tpl.html';
import controller from './DatePickerCtrl';

const ddo = {
  restrict: 'E',
  template,
  controller,
  controllerAs: '$ctrl',
  bindToContrller: {
      year: '=',
      month: '='
  }
};

export default angular.module('components.datePicker', [])
  .directive('datePicker', ddo)
  .name;
</code></pre>

<p>在这里，我们将组件的生命周期钩子的概念引入进来，借以摆脱link,complie中dom的操作，原因在于<strong>一个数据驱动的组件体系下，我们应该尽量减少DOM操作，因此理想状态下，组件是不需要link或compile方法的，而且controller在语义上更贴合mvvm架构。</strong>.</p>

<h4 id="provider-service-factory-constant-value">Provider、Service、Factory、Constant、Value</h4>

<p>Angualr1.x中，这几种服务大概可以定义成下面三种类型，
1. 工具类/工具方法
2. 一些应用级别的常量和存储单元
3. 依赖内置服务的一系列服务组件</p>

<p>首先，provider跟service、factory的区别在于，启动ng时可配置内置服务，脱离这些服务使用ES6 Module的方式，本身没有什么区别。</p>

<p><strong>provider.js</strong></p>

<pre><code>let apiPrefix = '';

function setPrefix(prefix) {
    apiPrefix = prefix;
}
function genResource(url) {
    return resource(apiPrefix + url);
}
export {
  setPrefix,
  genResource
}
</code></pre>

<p>usage</p>

<pre><code>import {setPrefix} from './provider.js';
setPrefix('rt_');
</code></pre>

<p>factory和service,其实这两者可以替换，service传入的是构造函数，通过new创建出实例，而factory传入的是工厂函数，通过对这个工厂函数的调用而创建实例。</p>

<p><strong>service.js</strong></p>

<pre><code>class ServiceA{}

app.service('serviceA', ServiceA);
</code></pre>

<p><strong>factory.js</strong></p>

<pre><code>class FactoryA{
  
}

app.factory('factoryA', ()=&gt; new FactoryA());
</code></pre>

<p>注意这边factory传入的是factoryA的实例，service则不同，它直接将构造函数传入，ng判断到它是构造函数的模式，会将实例返回回来。这和controller的定义方式相同。</p>

<p>Constant、Value这两个其实就是专门为应用级别的常量和存储单元而设计的，撇开ng，就和我们平时定义变量没有区别。
<strong>constant.js</strong></p>

<pre><code>export const VERSION = '1.0.1'; 
</code></pre>

<h4 id="总结">总结</h4>

<p>这次项目重构下来，我最大的感受就是重构的阻碍主要还是来自于对原先项目的依赖程度，原先项目虽然不可以说严谨，但起码可以说稳定，因此我们在原来的基础上尽量对其改造，期望它脱离angualr浓重的框架思维，但就目前而言，无意是失败的。当然我们的目的也不是脱离angular，旧的项目依然会依靠在angualr上进行开发，这次改造主要是让我们意识到ES6的便利性，
使得我们可以地组织下层的业务代码。而如果需要在组件和模块上脱离angular的思想，这就需要我们使用其他框架去改造我们的项目，比方说react，这正是我们下一阶段的重构目标。</p>

<!-- #### 参考列表：

- 徐飞 [Angular 1.x和ES6的结合](https://github.com/xufei/blog/issues/29)
- kutos [Angular1.x + ES6 开发风格指南](https://github.com/kuitos/kuitos.github.io/issues/34) -->

  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://paraofheaven.github.io/post/vscode%E8%B0%83%E8%AF%95%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://paraofheaven.github.io/post/vscode%E8%B0%83%E8%AF%95%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D/">vscode调试实例介绍</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
  </div>
</div>



  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'Your Disqus shortname';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

</div>
</div>
<script src="https://paraofheaven.github.io/js/ui.js"></script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'Your Google Analytics tracking ID', 'auto');
  ga('send', 'pageview');

</script>



</body>
</html>

